# 常规登录方式
## cookie session模式
Cookie是客户端技术弥补HTTP协议无状态的不足，Cookie就是由服务器发给客户端的特殊信息。浏览器发送http请求时会自动携带Cookie。
Session是服务端技术在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。
常规的认证系统把sessionId包存在Cookie中，这样浏览器每次发送请求会自动携带sessionId，服务端根据sessionId查询用户状态，验证权限等。

浏览器同源定义：如果两个 URL 的 protocol、port (如果有指定的话)和 host 都相同的话，则这两个 URL 是同源。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。

Cookie的同源和浏览器同源略微不同，Cookie不区分端口，如果两个url地址一样，只是端口不同那么浏览器认为它们共用一个Cookie。

优点：
- 安全，将状态保存在服务器端。
- 服务端对状态的控制能力强（包括登录时长、失效、修改权限）。

缺点：
- 不支持跨域。
- 占用服务器资源多。
- 扩展麻烦（可以通过session共享等实现）。

## token认证

1. 用户通过用户名和密码发送请求。
2. 服务器端程序验证。
3. 服务器端程序返回一个带签名的token 给客户端。
4. 客户端储存token,并且每次访问API都携带Token到服务器端的。
5. 服务端验证token，校验成功则返回请求数据，校验失败则返回错误码。

服务端通过安全算法验证token是否可信，比如jwt token 分为三部分。第一部分我们称它为头部（header),第二部分我们称其为载荷（payload)，第三部分是签证（signature)。将一二部分和密钥（密钥保存在服务端，只有服务端知道）加密生成第三部分。服务端通过计算一二部分和密钥值和第三部分是否相等，验证token是否有效的。

优点：
- 无状态、可扩展。
- 安全性。
- 可扩展性。
- 多平台跨域。（发送请求时token一般保存在http header中，不需要考虑跨域问题。）
- 更加适合前后端分离和微服务。
缺点：
- 服务端控制能力弱（token失效等难以处理）

# 单点登录
单点登录是指用户只需要认证一次，即可用一个身份访问所有在当前可信环境中的所有应用。
实现方式包括使用 cookie、jsonp、页面重定向 等等，也包括了一些单点登录标准协议例如 SAML、OIDC 等。

## 身份联邦

往往企业实现单点登录后，各系统身份仍然相对隔离没有打通，很可能应用系统自己的账密登录入口也仍然保留着，各系统仍然单独维护着独立的账号体系。这种情况的问题如下：

由于一套账号即可通用所有应用，需要依赖每个应用独立维护多因素认证，以达到最低安全要求，避免单点爆破，消耗研发资源。
员工离职后，需要手动为其从每个应用系统中删除/禁用信息。如有遗忘：
可能会造成长期信息泄露，造成潜在安全隐患。
可能会导致企业长期为离职员工维护企业软件 license，造成额外开支。
于此需求，「身份联邦」与「单点登录」的区别浮现出来。

身份联邦」是实现「单点登录」的一种标准方式，但「单点登录」远不是「身份联邦」的唯一目的。只要实现了「身份联邦」，即必然已经实现了「单点登录」，而反之不成立。

「身份联邦」的目的是用标准协议来打通不同安全域之间的用户身份，在跨域、跨产品、跨公司的场景中实现身份信息共享，包含了一系列认证、授权、身份治理、跨域身份同步、统一 license 管理、跨域字段转换的策略、协议和最佳实现。使用实现了「身份联邦」的 IAM 服务，将可以在企业 IT 架构中将身份与权限管理层完整抽离出来，并统一到一个安全平台进行管理。「身份联邦」是一个涵盖面非常广（且仍然在快速完善中）的词。

在「身份联邦」的实现中，浮现出了一个身份和权限访问的中央处理机制，负责统筹所有应用的访问服务。各应用系统不再单独维护独立的账号体系，全部转化为统一的登录入口，登录后将用户分发到希望访问的目标应用中去。

这个处理身份和权限管理的核心即为 IDP Identity Provider，在服务中处于身份提供方。其他的业务服务为 SP Service Provider，服务提供方。


# oauth2 单点登录
## oauth的四种模式

1. 授权码模式
2. 隐式授权模式/简化模式
3. 密码模式
4. 客户端凭证模式

oauth2的sso单点登录使用的是授权码模式，各部分中的角色如下
1. Resource Owner（资源拥有者：用户，单点登录中的用户）
2. Client （第三方接入平台：请求者，单点登录中的业务系统）
3. Resource Server （服务器资源：数据中心，单点登录中的可以没有）
4. Authorization Server （认证服务器，单点登录中的认证中心）

client 需要在Authorization Server提前注册，Authorization Server 需要把user-authorization-uri（获取code的接口），access-token-uri（获取token的接口），user-info-uri（获取用户信息的接口）暴露给client。

springboot client 和 Authorization Server 的信息配置如下图：

client 配置

[![6b7AMR.png](https://z3.ax1x.com/2021/03/24/6b7AMR.png)](https://imgtu.com/i/6b7AMR)

server 配置

[![6b78sI.png](https://z3.ax1x.com/2021/03/24/6b78sI.png)](https://imgtu.com/i/6b78sI)


## oauth2单点登录流程
1. 浏览器和业务系统（client）、认证中心（auth-server）实际上是用的session保存用户登录状态。在跳转的过程中seesion随着cookie自动发送到服务器，所以服务器可以判断用户是否登录。
2. 业务系统（client）和认证中心（auth-server）之间是使用token通信的，业务系统（client）通过token从认证中心（auth-server）获取用户信息。

[![6b3QgK.png](https://z3.ax1x.com/2021/03/24/6b3QgK.png)](https://imgtu.com/i/6b3QgK)

1. 浏览器访问业务系统A。
2. 业务系统A发现用户没有登录，跳转到认证中心。
3. 认证中心发现用户没有登录，跳转到登录页面。
4. 用户输入用户名、密码登录。在统一认真中心我们完成登录功能，登录完成。
5. 确认用户登录后，认证中心会跳转会业务系统A，并携带授权码。
6. 浏览器携带授权码访问业务系统A。
7. 业务系统A，使用授权码访问认证中心获取token。
8. 业务系统A，使用授token获取用户信息，走一遍自己的登录流程，用户完成业务系统A的登录。

## 实际中的跳转的url流程顺序

1. 用户访问 http://172.16.0.234:1112/hello， 业务系统A 发现用户没有登录。
2. 用户被跳转到 http://172.16.0.234:1112/login 登录接口页面，因为配置了@EnableOAuth2Sso，业务系统A的过滤器会拦截这个请求。
3. 业务系统A会将用户登录请求重定向到 
http://172.16.0.234:1111/oauth/authorize?client_id=javaboy&redirect_uri=http://172.16.0.234:1112/login&response_type=code&state=lxmWPF
这个地址我们配置的认证中心获取授权码的地址。
4. 认证中心发现用户没有登录，重定向到自己的登录页面http://172.16.0.234:1111/login.html。用户发送登录请求
http://172.16.0.234:1111/login 完成登录。
5. 认证中心登录后，重新跳转到第3步请求授权码的地址。http://172.16.0.234:1111/oauth/authorize?client_id=javaboy&redirect_uri=http://172.16.0.234:1112/login&response_type=code&state=lxmWPF 这是用户已经是登录状态，认证中心生成授权码。
6. 认证中心重新跳回业务系统A的地址 http://172.16.0.234:1112/login?code=NSW2AR&state=lxmWPF 并在地址中放入授权码。
7. 业务系统A使用收到的授权码访问 http://localhost:1111/oauth/token 从认证中心中获取token。
8. 业务系统A使用token 访问 http://localhost:1111/user 从认证中心中获取用户信息。
9. 业务系统A使用获取的用户信息走一遍登录流程，然后跳转到用户最开始访问的 http://172.16.0.234:1112/hello 地址。


